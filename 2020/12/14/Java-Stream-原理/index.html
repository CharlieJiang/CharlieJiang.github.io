<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Stream操作的分类&amp;emsp;&amp;emsp;Stream中的操作分为两类：中间操作和结束操作。中间操作只是一种标记，只有执行结束操作才会触发真正的计算。中间操作又可以分为无状态操作和有状态操作：无状态中间操作是指元素的操作不受前面元素的影响；有状态中间操作必须等到所有元素执行完毕才会知道最终结果。比如排序是有状态中间操作，在读取所有元素前并不能确定排序结果。结束操作又分为短路操作和非短路操作：短">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Stream 原理">
<meta property="og:url" content="http://example.com/2020/12/14/Java-Stream-%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Cocoas">
<meta property="og:description" content="Stream操作的分类&amp;emsp;&amp;emsp;Stream中的操作分为两类：中间操作和结束操作。中间操作只是一种标记，只有执行结束操作才会触发真正的计算。中间操作又可以分为无状态操作和有状态操作：无状态中间操作是指元素的操作不受前面元素的影响；有状态中间操作必须等到所有元素执行完毕才会知道最终结果。比如排序是有状态中间操作，在读取所有元素前并不能确定排序结果。结束操作又分为短路操作和非短路操作：短">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-14T12:59:21.000Z">
<meta property="article:modified_time" content="2020-12-30T12:45:28.312Z">
<meta property="article:author" content="Cocoas">
<meta property="article:tag" content="Stream原理">
<meta property="article:tag" content="Stream操作">
<meta property="article:tag" content="中间操作">
<meta property="article:tag" content="结束操作">
<meta property="article:tag" content="Stream流水线">
<meta property="article:tag" content="Stream并行计算">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/12/14/Java-Stream-%E5%8E%9F%E7%90%86/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java Stream 原理 | Cocoas</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cocoas</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
		<li>
          第三标题
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E6%93%8D%E4%BD%9C%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">Stream操作的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">Stream流水线解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%E6%96%B9%E5%BC%8F"><span class="nav-text">中间操作记录方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E5%8F%A0%E5%8A%A0%E6%96%B9%E5%BC%8F"><span class="nav-text">中间操作叠加方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E5%8F%A0%E5%8A%A0%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">中间操作叠加之后的执行方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98"><span class="nav-text">执行结果保存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="nav-text">Stream并行执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parallelStream%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">parallelStream是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8EparallelStream%E8%AE%A4%E8%AF%86Fork-Join%E6%A1%86%E6%9E%B6"><span class="nav-text">从parallelStream认识Fork&#x2F;Join框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8parallelStream%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="nav-text">使用parallelStream的利弊</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cocoas</p>
  <div class="site-description" itemprop="description">Android,Java,Android SDK,Kotlin,</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">121</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CharlieJiang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CharlieJiang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cocoasjiang@foxmail.com" title="E-Mail → mailto:cocoasjiang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/14/Java-Stream-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cocoas">
      <meta itemprop="description" content="Android,Java,Android SDK,Kotlin,">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cocoas">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java Stream 原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-14 20:59:21" itemprop="dateCreated datePublished" datetime="2020-12-14T20:59:21+08:00">2020-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-30 20:45:28" itemprop="dateModified" datetime="2020-12-30T20:45:28+08:00">2020-12-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80/Java-Stream/" itemprop="url" rel="index"><span itemprop="name">Java Stream</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Stream操作的分类"><a href="#Stream操作的分类" class="headerlink" title="Stream操作的分类"></a><strong>Stream操作的分类</strong></h2><p>&emsp;&emsp;Stream中的操作分为两类：中间操作和结束操作。中间操作只是一种标记，只有执行结束操作才会触发真正的计算。中间操作又可以分为无状态操作和有状态操作：无状态中间操作是指元素的操作不受前面元素的影响；有状态中间操作必须等到所有元素执行完毕才会知道最终结果。比如排序是有状态中间操作，在读取所有元素前并不能确定排序结果。结束操作又分为短路操作和非短路操作：短路操作是指不用处理完所有元素就可以返回的操作；非短路操作则是必须处理完所有元素才能返回的操作。  </p>
<a id="more"></a>

<table>
 <tr>
  <td>操作分类</td>
  <td>操作二级分类</td>
  <td>方法</td>
 </tr>
 <tr>
  <td rowspan="2">中间操作</td>
  <td>无状态中间操作</td>
  <td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>
 </tr>
 <tr>
  <td>有状态中间操作</td>
  <td>distinct()  sorted() limit() skip()</td>
 </tr>
 <tr>
  <td rowspan="2">结束操作</td>
  <td>非短路操作</td>
  <td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td>
 </tr>
 <tr>
  <td>短路操作</td>
  <td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>
 </tr>
</table>


<h2 id="Stream流水线解决方案"><a href="#Stream流水线解决方案" class="headerlink" title="Stream流水线解决方案"></a><strong>Stream流水线解决方案</strong></h2><p>&emsp;&emsp;所谓的流水线，就是由多个具有先后顺序的操作组成的操作序列。Stream中的流水线作用就是：记录用户的每一步中间操作，在用户调用结束操作时将之前记录的操作叠加在一起，尽量在一次迭代中执行完所有操作。为实现以上功能，流水线需要解决的问题是：  </p>
<ul>
<li>用户的操作如何记录</li>
<li>操作如何叠加</li>
<li>叠加之后的操作如何执行</li>
<li>执行的结果如何存放</li>
</ul>
<h3 id="中间操作记录方式"><a href="#中间操作记录方式" class="headerlink" title="中间操作记录方式"></a><strong>中间操作记录方式</strong></h3><p>&emsp;&emsp;<strong>Stage概念</strong>：很多Stream中间操作会需要一个回调函数（lambda表达式），因此一个完整的操作是由&lt;数据来源，操作，回调函数&gt;组成的三元组，Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的<code>PipelineHelper</code>来表示Stage，将具有先后顺序的各个Stage连接到一起，就构成了整个流水线。<br>&emsp;&emsp;Stream相关类和接口关系：<br>&emsp;&emsp;&emsp;&emsp;<code>PipelineHelper</code>：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>AbstractPipeline</code>：实现<code>BaseStream</code>接口<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>ReferencePipeline</code>：实现<code>Stream</code>接口<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>Head</code>：内部子类<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>StatelessOp</code>：内部子类<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>StatefulOp</code>：内部子类<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>DoublePipeline</code>：实现<code>DoubleStream</code>接口<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>IntPipeline</code>：实现<code>IntStream</code>接口<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>LongPipeline</code>：实现<code>LongStream</code>接口<br>&emsp;&emsp;上面的Head类表示流水线中的第一个Stage，即调用<code>Collection.stream()</code>方法产生的Stage，这个Stage里不包含任何操作 。<code>StatelessOp</code>和<code>StatefulOp</code>分别表示无状态的Stage和有状态的Stage，对应无状态和有状态的中间操作。</p>
<h3 id="中间操作叠加方式"><a href="#中间操作叠加方式" class="headerlink" title="中间操作叠加方式"></a><strong>中间操作叠加方式</strong></h3><p>&emsp;&emsp;Stream中间操作间通过<code>Sink</code>接口进行相互调用。  </p>
<p>&emsp;&emsp;<code>Sink</code>接口方法说明  </p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>void begin(long size)</td>
<td>开始遍历元素前调用，通知Sink做好准备</td>
</tr>
<tr>
<td>void end()</td>
<td>所有元素遍历完成后调用，通知Sink遍历完成</td>
</tr>
<tr>
<td>boolean cancellationRequested()</td>
<td>是否可以结束操作，可以让短路操作尽早结束</td>
</tr>
<tr>
<td>void accept(T t)</td>
<td>遍历元素时调用，接受一个待处理元素，并对元素进行处理</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;Stage把自己的操作和回调函数封装到<code>Sink.accept()</code>中，前一个<code>Sink</code>只需要调用当前<code>Sink.accept()</code>方法即可，不用关心当前<code>Sink</code>的具体实现。<br>&emsp;&emsp;一种可能的<code>accept()</code>方法实现如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">U</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     <span class="token number">1</span>、使用当前<span class="token class-name">Sink</span>包装的回调函数处理u
     <span class="token number">2</span>、将处理结果传递给流水线下游的<span class="token class-name">Sink</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;对于有状态的操作，<code>Sink</code>的<code>begin()</code>方法和<code>end()</code>方法是必须实现的；对于短路操作，<code>Sink.cancellationRequested()</code>方法也是必须实现的。实际上，Stream API内部实现的本质,就是如何重载<code>Sink</code>的这四个方法。  </p>
<h3 id="中间操作叠加之后的执行方式"><a href="#中间操作叠加之后的执行方式" class="headerlink" title="中间操作叠加之后的执行方式"></a><strong>中间操作叠加之后的执行方式</strong></h3><p>&emsp;&emsp;触发执行：当调用一个结束操作时，便会触发流水线上所有的操作执行。<br>&emsp;&emsp;<code>Sink</code>嵌套：Stage在使用<code>AbstractPipeline.opWrapSink()</code>方法构造自己的<code>Sink</code>时，将当前操作与下游<code>Sink</code>结合成新的Sink返回，所以从最后一个Stage向上回溯不断调用上一个Stage的<code>opWrapSink()</code>方法，就可以得到一个包含流水线上所有操作的<code>Sink</code>。<code>PipelineHelper.wrapSink()</code>方法就是这么实现的：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span> <span class="token class-name">Sink</span><span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span> <span class="token function">wrapSink</span><span class="token punctuation">(</span><span class="token class-name">Sink</span><span class="token generics"><span class="token punctuation">&lt;</span>E_OUT<span class="token punctuation">></span></span> sink<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span> <span class="token class-name">AbstractPipeline</span> p<span class="token operator">=</span><span class="token class-name">AbstractPipeline</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">;</span> p<span class="token punctuation">.</span>depth <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token punctuation">.</span>previousStage<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        sink <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">opWrapSink</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>previousStage<span class="token punctuation">.</span>combinedFlags<span class="token punctuation">,</span> sink<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Sink</span><span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span><span class="token punctuation">)</span> sink<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;执行流水线操作：现在流水线上从开始到结束的所有操作都被包含进一个<code>Sink</code>中，执行这个<code>Sink</code>就相当于执行整个流水线操作。<code>PipelineHelper.copyInfo()</code>方法就是这么实现的：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span> <span class="token keyword">void</span> <span class="token function">copyInto</span><span class="token punctuation">(</span><span class="token class-name">Sink</span><span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span> wrappedSink<span class="token punctuation">,</span> <span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span>P_IN<span class="token punctuation">></span></span> spliterator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>wrappedSink<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StreamOpFlag</span><span class="token punctuation">.</span>SHORT_CIRCUIT<span class="token punctuation">.</span><span class="token function">isKnown</span><span class="token punctuation">(</span><span class="token function">getStreamAndOpFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        wrappedSink<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span>spliterator<span class="token punctuation">.</span><span class="token function">getExactSizeIfKnown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        spliterator<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>wrappedSink<span class="token punctuation">)</span><span class="token punctuation">;</span>
        wrappedSink<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">copyIntoWithCancel</span><span class="token punctuation">(</span>wrappedSink<span class="token punctuation">,</span> spliterator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="执行结果保存"><a href="#执行结果保存" class="headerlink" title="执行结果保存"></a><strong>执行结果保存</strong></h3><p>&emsp;&emsp;不是所有的结束操作都会有返回值，如<code>forEach()</code>就不会有返回值。<br>&emsp;&emsp;根据返回值将结束操作分类如下：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>结束操作</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>anyMatch() allMatch() noneMatch()</td>
</tr>
<tr>
<td>Optinal</td>
<td>findFirst() findAny()</td>
</tr>
<tr>
<td>规约结果</td>
<td>reduce() collect()</td>
</tr>
<tr>
<td>数组</td>
<td>toArray()</td>
</tr>
<tr>
<td>void</td>
<td>forEach() forEachOrdered()</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;返回<code>boolean</code>或<code>Optional</code>的操作：由于只返回一个值，只需要在对应的<code>Sink</code>中记录这个值，等到执行结束后返回这个值就行了。<br>&emsp;&emsp;对于规约操作，最终结果放在用户调用时指定的容器中。<br>&emsp;&emsp;返回数组的操作，最终结果存放在数组中。但在返回数组前，数据是存放在一种<code>Node</code>的数据结构中。  </p>
<h2 id="Stream并行执行"><a href="#Stream并行执行" class="headerlink" title="Stream并行执行"></a><strong>Stream并行执行</strong></h2><p>&emsp;&emsp;Stream在处理数据的一些迭代操作时确实很方便，但是在执行一些耗时或占用资源很高的任务时，串行化的流并不能带来速度/性能上的提升，并不能满足我们的需要。通常我们会使用多线程来并行或分片分解执行任务。Stream中也提供了这样的并行方法，那就是使用<code>parallelStream()</code>方法或是使用<code>stream().parallel()</code>来转化为并行流。  </p>
<h3 id="parallelStream是什么"><a href="#parallelStream是什么" class="headerlink" title="parallelStream是什么"></a><strong>parallelStream是什么</strong></h3><p>&emsp;&emsp;先看下<code>Collection</code>接口提供的并行流方法<code>parallelStream()</code>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Returns a possibly parallel &#123;@code Stream&#125; with this collection as its
 * source.  It is allowable for this method to return a sequential stream.
 *
 * &lt;p>This method should be overridden when the &#123;@link #spliterator()&#125;
 * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;,
 * &#123;@code CONCURRENT&#125;, or &lt;em>late-binding&lt;/em>. (See &#123;@link #spliterator()&#125;
 * for details.)
 *
 * @implSpec
 * The default implementation creates a parallel &#123;@code Stream&#125; from the
 * collection's &#123;@code Spliterator&#125;.
 *
 * @return a possibly parallel &#123;@code Stream&#125; over the elements in this
 * collection
 * @since 1.8
 */</span>
<span class="token keyword">default</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token class-name">StreamSupport</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;其中代码注释的返回值 <code>@return a possibly parallel</code>一句说明了调用这个方法，只是可能会返回一个并行流，流是否能并行执行还受到一些其他条件的影响。parallelStream其实就是一个并行执行的流，它通过默认的<code>ForkJoinPool</code>，可能会提高多线程任务的速度。<br>&emsp;&emsp;parallelStream并行执行效果测试：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Stream并行流执行测试</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Thread</span> th <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"value = "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">" ，currentThread = "</span> <span class="token operator">+</span> th<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;输出</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">value <span class="token operator">=</span> two ，currentThread <span class="token operator">=</span> main
value <span class="token operator">=</span> one ，currentThread <span class="token operator">=</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span>commonPool<span class="token operator">-</span>worker<span class="token operator">-</span><span class="token number">1</span>
value <span class="token operator">=</span> three ，currentThread <span class="token operator">=</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span>commonPool<span class="token operator">-</span>worker<span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;从运行结果我们可以很清楚的看到，parallelStream同时使用了主线程和<code>ForkJoinPool.commonPool</code>创建的线程。值得注意的是，这个运行结果并不是唯一的，甚至你的运行结果里可能只有主线程。<br>&emsp;&emsp;parallelStream内部使用了默认的<code>ForkJoinPool.commonPool</code>，其默认的线程数量就是你的处理器数量，这个值是由<code>Runtime.getRuntime().avaliable - Processors()</code>得到的，但是你可以通过系统属性<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>来改变线程池大小。这是一个全局设置，它将影响代码中的所有并行流。也就是说，目前还无法专门为某个并行流指定这个值。一般来说，使用这个默认值即可。<br>&emsp;&emsp;parallelStream并行执行时线程数量设置测试：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 并行流线程数设置测试</span>
<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置2</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">getCommonPoolParallelism</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>
<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span><span class="token punctuation">,</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置 10</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">getCommonPoolParallelism</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;为什么两次运行的结果一样呢？因为<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>是final型的全局变量，在整个JVM中只能设置一次。不过，我们可以通过手动引入<code>ForkJoinPool</code>来实现并发线程数的反复修改：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用ForkJoinPool实现并发线程数多次修改</span>
<span class="token class-name">IntStream</span> intStream <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> intStream<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&emsp;&emsp;注意：<br>&emsp;&emsp;&emsp;&emsp;①、多个parallelStream默认使用的是同一个线程池，所以IO操作尽量不要放进parallelStream中，以免阻塞其它parallelStream。<br>&emsp;&emsp;&emsp;&emsp;②、parallelStream的默认并发线程数量要比CPU处理器的数量少1，因为最优的策略是每个CPU处理器分配一个线程，而主线程也需要占用一个CPU处理器。如下并发线程数量与处理器数量测试：  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取当前机器的处理器数量</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 4</span>
<span class="token comment">// 获取parallelStream的默认并发线程数量</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">getCommonPoolParallelism</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="从parallelStream认识Fork-Join框架"><a href="#从parallelStream认识Fork-Join框架" class="headerlink" title="从parallelStream认识Fork/Join框架"></a><strong>从parallelStream认识Fork/Join框架</strong></h3><p>&emsp;&emsp;Fork/Join框架核心：分治法思想。Fork负责分配任务，Join负责合并任务执行结果。<br>&emsp;&emsp;分治法就是将一个大任务拆分为互不依赖的小任务，将这些小任务分别放到不同的队列中，并为每个队列创建独立的线程来执行队列中的任务。同时，为了更大程度地提高并行线程的处理能力，采用了工作窃取算法来运行任务。也就是说当某个线程处理完自己工作队列中的任务后，尝试从其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。不过为了减少线程之间的竞争，通常会使用双端队列存放任务，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。<br>&emsp;&emsp;简单来说就是：大任务拆小任务，不同线程执行小任务，合并小任务执行结果后返回。也就是第一步拆分，第二步分别执行，第三步合并，这三个步骤分别对应的就是<code>Collector</code>的<code>supplier</code>、<code>accumulator</code>和<code>combiner</code>。  </p>
<h3 id="使用parallelStream的利弊"><a href="#使用parallelStream的利弊" class="headerlink" title="使用parallelStream的利弊"></a><strong>使用parallelStream的利弊</strong></h3><p>&emsp;&emsp;好处：<br>&emsp;&emsp;&emsp;&emsp;①、简化代码，可以使用lambda表达式。<br>&emsp;&emsp;&emsp;&emsp;②、使用多核特性并行处理，大幅提高效率。<br>&emsp;&emsp;需要注意的地方：<br>&emsp;&emsp;①、parallelStream是非线程安全的。使用parallelStream调用某些方法等在多线程环境下可能会存在并发问题。解决方式是，加锁、使用线程安全的方法或使用Stream的<code>collect()</code>操作/<code>reduce()</code>操作。<br>&emsp;&emsp;&emsp;&emsp;②、parallelStream使用的场景是CPU密集型的，当电脑本身CPU的负载很大时，使用并行流并不会起到作用。<br>&emsp;&emsp;&emsp;&emsp;③、不要在多线程中使用parallelStream，原因与上面类似，大家都抢着CPU是没有提升效果的，反而还会加大线程切换开销。<br>&emsp;&emsp;&emsp;&emsp;④、parallelStream会带来不确定性，请确保每条处理无状态且没有关联。<br>&emsp;&emsp;&emsp;&emsp;⑤、考虑NQ模型：N可用的数据量，Q针对每个数据元素执行的计算量，乘积 N * Q 越大，就越有可能获得并行提速。N * Q&gt;10000（大概是集合大小超过1000） 就会获得有效提升。<br>&emsp;&emsp;&emsp;&emsp;⑥、parallelStream是创建一个并行的Stream,而且它的并行操作是不具备线程传播性的,所以是无法获取<code>ThreadLocal</code>创建的线程变量的值。<br>&emsp;&emsp;&emsp;&emsp;⑦、在使用并行流的时候是无法保证元素的顺序的，也就是即使你用了同步集合也只能保证元素都正确但无法保证其中的顺序。<br>&emsp;&emsp;&emsp;&emsp;⑧、lambda的执行并不是瞬间完成的，所有使用parallel stream的程序都有可能成为阻塞程序的源头，并且在执行过程中程序中的其他部分将无法访问这些workers，这意味着任何依赖parallel streams的程序在什么别的东西占用着common ForkJoinPool时将会变得不可预知并且暗藏危机。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CarpenterLee/p/6637118.html">深入理解Java Stream流水线</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://github.com/CharlieJiang">
          <span class="icon">
            <i class="fab fa-github"></i>
          </span>

          <span class="label">GitHub</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Stream%E5%8E%9F%E7%90%86/" rel="tag"># Stream原理</a>
              <a href="/tags/Stream%E6%93%8D%E4%BD%9C/" rel="tag"># Stream操作</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C/" rel="tag"># 中间操作</a>
              <a href="/tags/%E7%BB%93%E6%9D%9F%E6%93%8D%E4%BD%9C/" rel="tag"># 结束操作</a>
              <a href="/tags/Stream%E6%B5%81%E6%B0%B4%E7%BA%BF/" rel="tag"># Stream流水线</a>
              <a href="/tags/Stream%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" rel="tag"># Stream并行计算</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/11/Java-Stream%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" rel="prev" title="Java Stream接口常用方法使用说明">
                  <i class="fa fa-chevron-left"></i> Java Stream接口常用方法使用说明
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/30/Java-Stream-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="Java Stream 源码解析">
                  Java Stream 源码解析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-at"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cocoas的博客</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  


















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

</body>
</html>
